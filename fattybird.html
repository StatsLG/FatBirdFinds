<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fatty Bird — Game</title>
  <style>
    :root{
      --bg:#0e1b2a; --fg:#e8f0fe; --muted:#9fb3c8; --accent:#52d67a;
      --card:#122033; --danger:#ef476f;
    }
    html,body{height:100%}
    body{margin:0; background:linear-gradient(180deg,#1b2a41 0%,#0e1b2a 100%); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial; display:grid; place-items:center}
    .wrap{display:flex; flex-direction:column; gap:.75rem; align-items:center}
    canvas{background:linear-gradient(180deg,#6ec1ff 0%, #bde0ff 60%, #e6f4ff 100%); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); touch-action:none}
    .hud{display:flex; gap:.5rem; align-items:center; justify-content:center; flex-wrap:wrap; opacity:.95}
    .btn{appearance:none; border:0; border-radius:999px; padding:.6rem 1rem; font-weight:700; color:#00121f; background:var(--accent); box-shadow:0 8px 18px rgba(82,214,122,.35); cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .muted{color:var(--muted)}
    /* Modal */
    .modal{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.5); padding:16px; z-index:999}
    .hidden{display:none}
    .card{background:var(--card); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); padding:18px; width:min(520px, 92vw)}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    input[type=text]{flex:1 1 220px; background:#0c1726; color:var(--fg); border:1px solid #274160; border-radius:10px; padding:8px 10px}
    .status{min-height:1.25em}
    .danger{background:var(--danger); color:#00121f}
    .right{margin-left:auto}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="420" height="640" aria-label="Fatty Bird"></canvas>
    <div class="hud">
      <a id="homeBtn" class="btn" href="index.html" title="Back to home">Home</a>
      <button id="flapBtn" class="btn" title="Space/Click/Tap to flap">Flap</button>
      <button id="restartBtn" class="btn" title="Enter to restart">Restart</button>
      <span class="muted">Controls: Space / Click / Tap · Restart: Enter</span>
    </div>
  </div>

  <!-- Game Over modal -->
  <div id="gameOver" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="goTitle">
    <div class="card">
      <h2 id="goTitle" style="margin:0 0 8px 0">Game Over</h2>
      <p style="margin:4px 0 12px 0">
        Score: <b id="goScore">0</b> · Best (device): <b id="goBest">0</b>
      </p>

      <div class="row" style="margin:8px 0">
        <input id="goName" type="text" placeholder="Your name" maxlength="24" />
        <button id="goSubmit" class="btn">Submit to Leaderboard</button>
        <button id="goSkip" class="btn danger">Skip</button>
        <a id="goHome" class="btn" href="index.html">Home</a>
        <span class="right muted">Submits to shared leaderboard</span>
      </div>

      <div id="goStatus" class="status muted"></div>

      <div class="row" style="margin-top:12px">
        <button id="goAgain" class="btn">Play Again</button>
      </div>
    </div>
  </div>

  <script>
  "use strict";
  // ========= CONFIG =========
  // Shared leaderboard backend (Google Apps Script Web App — ends with /exec)
  const BACKEND_URL = "https://script.google.com/macros/s/AKfycbwoZ8_K9itPH9e9tbUprW4cSeRzZcEu6x6rHZlGQjx-xT5qsbOV7Uvfk08KagoHkH1g/exec";
  // Auto-submit if we already know the player's name:
  const AUTO_SUBMIT_IF_NAME = true;

  // Pull the version param from the homepage link to bust caches
  const qs = new URLSearchParams(location.search);
  const VERSION = qs.get('v') || "";
  const ASSET_V = VERSION ? `?v=${VERSION}` : "";

  // YOUR SPRITES (PNG with transparency). Adjust paths if they’re in a folder.
  const BIRD_IMG_SRC = `fbfnobg.png${ASSET_V}`;    // e.g., 'img/fbfnobg.png' + ASSET_V
  const PIPE_IMG_SRC = `swungnobg.png${ASSET_V}`;  // e.g., 'img/swungnobg.png' + ASSET_V

  // Visual scales
  const BIRD_SCALE = 2.0;   // your chosen visual scale
  const PIPE_SCALE_X = 1.0;

  // ---------- HITBOX TUNING ----------
  const HB = {
    bird: {
      scale: 0.8,      // multiply visual radius (smaller = more forgiving)
      offsetX: 0,       // shift hit center in px (left-/right+)
      offsetY: 2,       // shift hit center in px (up-/down+)
      useEllipse: false,// true to use ellipse instead of circle
      rxScale: 1.00,    // ellipse x radius multiplier
      ryScale: 0.85     // ellipse y radius multiplier
    },
    pipe: {
      insetX: 8,        // trim pipe rects at left/right (px)
      insetTop: 8,      // trim from top pipe bottom edge (px)
      insetBottom: 8    // trim from bottom pipe top edge (px)
    },
    debug: false        // set true to draw hitboxes overlay
  };

  function rVisual(){ return 14 * BIRD_SCALE; } // visual radius
  function rHit(){ return rVisual() * HB.bird.scale; }
  function birdCenter(){ return { x: bird.x + HB.bird.offsetX, y: bird.y + HB.bird.offsetY }; }

  // ========= CANVAS =========
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height, GROUND_H = 60;

  // ========= SPRITES =========
  const SPRITES = { bird:new Image(), pipe:new Image(), birdReady:false, pipeReady:false };
  if (BIRD_IMG_SRC) {
    SPRITES.bird.src = BIRD_IMG_SRC;
    SPRITES.bird.onload = ()=>SPRITES.birdReady=true;
    SPRITES.bird.onerror = (e)=>console.error("Bird image failed to load:", BIRD_IMG_SRC, e);
  }
  if (PIPE_IMG_SRC) {
    SPRITES.pipe.src = PIPE_IMG_SRC;
    SPRITES.pipe.onload = ()=>SPRITES.pipeReady=true;
    SPRITES.pipe.onerror = (e)=>console.error("Pipe image failed to load:", PIPE_IMG_SRC, e);
  }

  // ========= STATE =========
  const bird = { x: 90, y: H*0.4, r: 14, vy: 0 };
  const GRAVITY=0.45, FLAP=-7.6, MAX_FALL=12;
  const pipes=[], PIPE_W=66, GAP_H=160, PIPE_SPEED=2.4, SPAWN_FRAMES=95;
  let frame=0, score=0, best= +(localStorage.getItem('best_flappy')||'0'), alive=true, started=false;

  // ========= UI (modal) =========
  const modal = document.getElementById('gameOver');
  const goScore = document.getElementById('goScore');
  const goBest = document.getElementById('goBest');
  const goName = document.getElementById('goName');
  const goStatus = document.getElementById('goStatus');
  const goSubmit = document.getElementById('goSubmit');
  const goSkip = document.getElementById('goSkip');
  const goAgain = document.getElementById('goAgain');
  const goHome = document.getElementById('goHome');
  const homeBtn = document.getElementById('homeBtn');

  // Make Home links carry version (for cache-busting symmetry)
  const homeUrl = `index.html${VERSION ? `?v=${VERSION}` : ''}`;
  if(homeBtn) homeBtn.href = homeUrl;
  if(goHome) goHome.href = homeUrl;

  // Pre-fill name if saved
  goName.value = localStorage.getItem('player_name') || '';

  function showModal(curScore){
    goScore.textContent = String(curScore);
    goBest.textContent = String(best);
    goStatus.textContent = '';
    modal.classList.remove('hidden');

    // Auto-submit if name remembered
    if (AUTO_SUBMIT_IF_NAME && goName.value.trim() && BACKEND_URL) {
      submitScore(goName.value.trim(), curScore, /*silent*/true);
    }
  }
  function hideModal(){ modal.classList.add('hidden'); }

  async function submitScore(name, sc, silent=false){
    try{
      localStorage.setItem('player_name', name);
      if(!silent) goStatus.textContent = 'Submitting…';
      const res = await fetch(BACKEND_URL, {
        method: 'POST',
        // Form-encoded to avoid CORS preflight; Apps Script reads e.parameter
        body: new URLSearchParams({ name, score: String(sc) })
      });
      // We don't rely on response body (some blockers make it opaque). Only check status.
      if (!res || (res.status !== 200 && res.type !== 'opaque')) throw new Error('Submit failed');
      if(!silent) goStatus.textContent = (res.type === 'opaque') ? 'Submitted (pending)' : 'Submitted ✔';
    }catch(e){
      // Fallback fire-and-forget: opaque request still reaches GAS in many setups
      try{
        await fetch(BACKEND_URL, { method:'POST', mode:'no-cors', body:new URLSearchParams({ name, score:String(sc) }) });
        if(!silent) goStatus.textContent = 'Submitted (pending)';
      }catch(e2){ if(!silent) goStatus.textContent = 'Submit failed.'; }
      console.warn('Submit error:', e);
    }
  }

  // ========= GAME CORE =========
  function reset(){
    pipes.length = 0;
    bird.y = H*0.45; bird.vy = 0;
    frame=0; score=0; alive=true; started=false;
    hideModal();
  }

  function spawnPipe(){
    const margin=50;
    const topHeight = Math.floor(Math.random()*(H - GROUND_H - GAP_H - margin*2)) + margin;
    pipes.push({ x: W+10, gapY: topHeight, passed:false });
  }

  function flap(){
    if(!alive){ return; }
    started = true;
    bird.vy = FLAP;
  }

  function circleIntersectsRect(cx, cy, r, rect){
    const x=rect.x, y=rect.y, w=rect.w, h=rect.h;
    const nx = Math.max(x, Math.min(cx, x+w));
    const ny = Math.max(y, Math.min(cy, y+h));
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) < r*r;
  }

  function ellipseIntersectsRect(cx, cy, rx, ry, rect){
    const sx = 1/rx, sy = 1/ry;
    const rc = { x: rect.x*sx, y: rect.y*sy, w: rect.w*sx, h: rect.h*sy };
    return circleIntersectsRect(cx*sx, cy*sy, 1, rc);
  }

  function pipeRects(p){
    const pipeW = PIPE_W * PIPE_SCALE_X;
    const top = { x:p.x, y:0, w:pipeW, h:p.gapY };
    const botY = p.gapY + GAP_H;
    const bot = { x:p.x, y:botY, w:pipeW, h:H - GROUND_H - botY };
    const insetX = HB.pipe.insetX;
    const topDef = {
      x: top.x + insetX, y: top.y,
      w: Math.max(0, top.w - insetX*2),
      h: Math.max(0, top.h - HB.pipe.insetTop)
    };
    const botDef = {
      x: bot.x + insetX, y: bot.y,
      w: Math.max(0, bot.w - insetX*2),
      h: Math.max(0, bot.h - HB.pipe.insetBottom)
    };
    return { top: topDef, bottom: botDef };
  }

  function update(){
    if(alive && started){
      bird.vy = Math.min(bird.vy + GRAVITY, MAX_FALL);
      bird.y += bird.vy;

      if(frame % SPAWN_FRAMES === 0) spawnPipe();
      for(let i=0;i<pipes.length;i++){ pipes[i].x -= PIPE_SPEED; }
      while(pipes.length && pipes[0].x + PIPE_W < -20){ pipes.shift(); }

      // scoring (use scaled center+radius)
      for(const p of pipes){
        const { x: cx } = birdCenter();
        if(!p.passed && p.x + PIPE_W < cx - rHit()){
          p.passed = true; score++;
          if(score > best){ best = score; localStorage.setItem('best_flappy', String(best)); }
        }
      }

      // ceiling / ground
      {
        const { x: cx, y: cy } = birdCenter();
        if(cy - rHit() < 0){ bird.y = (rHit() - HB.bird.offsetY); bird.vy = 0; }
        if(cy + rHit() > H - GROUND_H){ alive = false; }
      }

      // pipe collisions (deflated rects + optional ellipse)
      for(const p of pipes){
        const { top: topRect, bottom: botRect } = pipeRects(p);
        const { x: cx, y: cy } = birdCenter();
        let hit = false;
        if (HB.bird.useEllipse) {
          const rx = rHit() * HB.bird.rxScale;
          const ry = rHit() * HB.bird.ryScale;
          hit = ellipseIntersectsRect(cx, cy, rx, ry, topRect) ||
                ellipseIntersectsRect(cx, cy, rx, ry, botRect);
        } else {
          hit = circleIntersectsRect(cx, cy, rHit(), topRect) ||
                circleIntersectsRect(cx, cy, rHit(), botRect);
        }
        if(hit){ alive = false; break; }
      }
    } else if(!alive){
      if(modal.classList.contains('hidden')){ showModal(score); }
    }
    frame++;
  }

  // ========= DRAWING =========
  function drawBackground(){
    const t = frame * 0.3;
    drawCloud((W - (t % (W+120))) - 120, 90, 1.0);
    drawCloud((W - ((t+200) % (W+160))) - 160, 160, 0.8);
  }
function drawCloud(x,y,s){
  // Draw a golden ?-box instead of a cloud
  const size = 36 * s;         // base box size
  const x0 = x - size/2, y0 = y - size/2;
  const r  = 6 * s;            // corner radius

  // Face gradient
  const g = ctx.createLinearGradient(x0, y0, x0, y0 + size);
  g.addColorStop(0.00, '#ffe08a');
  g.addColorStop(0.45, '#f7c948');
  g.addColorStop(1.00, '#e0a106');

  // Rounded-rect box
  ctx.fillStyle = g;
  ctx.strokeStyle = '#8a5a00';
  ctx.lineWidth = Math.max(2, 2*s);

  ctx.beginPath();
  ctx.moveTo(x0 + r, y0);
  ctx.lineTo(x0 + size - r, y0);
  ctx.quadraticCurveTo(x0 + size, y0, x0 + size, y0 + r);
  ctx.lineTo(x0 + size, y0 + size - r);
  ctx.quadraticCurveTo(x0 + size, y0 + size, x0 + size - r, y0 + size);
  ctx.lineTo(x0 + r, y0 + size);
  ctx.quadraticCurveTo(x0, y0 + size, x0, y0 + size - r);
  ctx.lineTo(x0, y0 + r);
  ctx.quadraticCurveTo(x0, y0, x0 + r, y0);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Corner screws
  const screwR = 2.5 * s;
  const screws = [
    [x0 + r, y0 + r], [x0 + size - r, y0 + r],
    [x0 + r, y0 + size - r], [x0 + size - r, y0 + size - r]
  ];
  ctx.fillStyle = '#d9e2ec';
  ctx.strokeStyle = 'rgba(0,0,0,.25)';
  screws.forEach(([sx, sy])=>{ ctx.beginPath(); ctx.arc(sx, sy, screwR, 0, Math.PI*2); ctx.fill(); ctx.stroke(); });

  // Question mark
  ctx.fillStyle = '#3b2f2f';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `bold ${22*s}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
  ctx.fillText('?', x, y - size*0.06);
}

  function getPipeGradient(x){
    const g = ctx.createLinearGradient(x,0,x+PIPE_W,0);
    g.addColorStop(0,'#1e854e'); g.addColorStop(1,'#2ecc71');
    return g;
  }

  function drawPipes(){
    for(const p of pipes){
      const pipeW = PIPE_W * PIPE_SCALE_X;
      const topH = p.gapY;
      const botY = p.gapY + GAP_H;
      const botH = H - GROUND_H - botY;

      if (SPRITES.pipeReady) {
        // top (flip vertically)
        ctx.save(); ctx.translate(p.x + pipeW/2, topH/2); ctx.scale(1,-1);
        ctx.drawImage(SPRITES.pipe, -pipeW/2, -topH/2, pipeW, topH); ctx.restore();
        // bottom
        ctx.drawImage(SPRITES.pipe, p.x, botY, pipeW, botH);
      } else {
        ctx.fillStyle = getPipeGradient(p.x);
        ctx.fillRect(p.x, 0, pipeW, topH);
        ctx.fillStyle = 'rgba(0,0,0,.08)';
        ctx.fillRect(p.x-2, topH-10, pipeW+4, 10);
        ctx.fillStyle = getPipeGradient(p.x);
        ctx.fillRect(p.x, botY, pipeW, botH);
        ctx.fillStyle = 'rgba(0,0,0,.08)';
        ctx.fillRect(p.x-2, botY, pipeW+4, 10);
      }
    }
  }

  function drawBird(){
    ctx.save();
    ctx.translate(bird.x, bird.y);
    const tilt = Math.max(-0.6, Math.min(0.6, bird.vy/10));
    ctx.rotate(tilt);

    if (SPRITES.birdReady) {
      const w = (bird.r*2) * BIRD_SCALE;
      ctx.drawImage(SPRITES.bird, -w/2, -w/2, w, w);
    } else {
      // vector fallback
      ctx.fillStyle='#ffd166';
      ctx.beginPath(); ctx.arc(0,0,bird.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#f4a261';
      ctx.beginPath(); ctx.ellipse(-2, 2, bird.r*0.7, bird.r*0.45, -0.5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(bird.r*0.35, -bird.r*0.28, bird.r*0.35, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.arc(bird.r*0.45, -bird.r*0.28, bird.r*0.16, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff9f1a';
      ctx.beginPath(); ctx.moveTo(bird.r*0.6, 0); ctx.lineTo(bird.r*1.2, -bird.r*0.1); ctx.lineTo(bird.r*0.6, bird.r*0.2); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  }

  function drawGround(){ ctx.fillStyle='#3e4c59'; ctx.fillRect(0, H-GROUND_H, W, GROUND_H); }

  function drawHUD(){
    ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(8,8,132,56);
    ctx.fillStyle='#fff';
    ctx.font='bold 18px system-ui,-apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Score: '+score, 16, 32);
    ctx.fillText('Best:  '+best, 16, 56);

    if(!started){
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff';
      ctx.font='bold 26px system-ui,-apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign='center'; ctx.fillText('Tap / Click / Space to start', W/2, H/2 - 12);
      ctx.font='16px system-ui,-apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Fly through the gaps!', W/2, H/2 + 16); ctx.textAlign='left';
    }
    if(!alive){ ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(0,0,W,H); }
  }

  function drawHitboxes(){
    if (!HB.debug) return;
    // Bird
    const { x: cx, y: cy } = birdCenter();
    ctx.save();
    ctx.strokeStyle = 'rgba(255,0,0,.8)';
    ctx.lineWidth = 2;
    if (HB.bird.useEllipse) {
      const rx = rHit() * HB.bird.rxScale;
      const ry = rHit() * HB.bird.ryScale;
      ctx.beginPath(); ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.arc(cx, cy, rHit(), 0, Math.PI*2); ctx.stroke();
    }
    ctx.restore();

    // Pipes
    ctx.save();
    ctx.strokeStyle = 'rgba(0,255,0,.8)';
    ctx.lineWidth = 2;
    for (const p of pipes) {
      const { top, bottom } = pipeRects(p);
      ctx.strokeRect(top.x, top.y, top.w, top.h);
      ctx.strokeRect(bottom.x, bottom.y, bottom.w, bottom.h);
    }
    ctx.restore();
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawPipes();
    drawBird();
    drawGround();
    drawHUD();
    drawHitboxes();
  }

  function loop(){ update(); render(); requestAnimationFrame(loop); }

  // ========= INPUT =========
  document.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){ e.preventDefault(); flap(); }
    else if(e.code === 'ArrowUp'){ flap(); }
    else if(e.code === 'Enter'){ if(!alive){ reset(); } }
  });
  canvas.addEventListener('pointerdown', ()=>{ if(alive){ flap(); } });
  document.getElementById('flapBtn').addEventListener('click', flap);
  document.getElementById('restartBtn').addEventListener('click', reset);

  // Modal actions
  goSubmit.addEventListener('click', ()=> {
    const name = (goName.value||'').trim() || 'Anonymous';
    submitScore(name, score);
  });
  goName.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); goSubmit.click(); } });
  goSkip.addEventListener('click', ()=> { goStatus.textContent = 'Skipped.'; });
  goAgain.addEventListener('click', reset);

  // ========= START =========
  reset();
  loop();
  </script>
</body>
</html>